# 主要流程详解

## 1. 主程序流程 (main函数)
主程序 zoneMain.cpp 是整个程序的入口点：

1. 创建 Info 对象并设置计算参数
   - 设置方程类型: `info->eqType = EULER`
   - 设置插值方法: `info->interMethod = TCNS5`
   - 设置差分方法: `info->diffMethod = MND6`
2. 根据预设算例配置计算参数
   - 通过 `presetCase` 变量选择算例 (默认为2，即Lax问题)
   - 调用 configureCase 函数配置具体参数
3. 创建 BlockSolver 对象，触发整个计算环境的初始化
4. 开始计时并执行求解循环
   - 对于EULER方程使用 `bSolver.stepsLoopCFL()` 
   - 其他方程使用 `bSolver.stepsLoop()`
5. 输出计算时间和统计信息

## 2. 初始化流程
BlockSolver 构造函数中触发的初始化过程：

1. 创建 Info、Block、Initializer、Equation、Bnds、SpDistributor 等组件
2. Initializer 初始化均匀网格: `initer->initUniformBlock(block)`
3. Initializer 初始化方程系统: `initer->initEqution(eqn,block)`
4. Initializer 初始化边界条件: `initer->initBnds(bnds,eqn,block->getICMax(),block)`
5. Initializer 初始化空间分布器: `initer->initSpDistributor(spDis,eqn,block,bnds)`

## 3. 时间推进流程
BlockSolver 中的时间推进方法（以 RK3_SSP 为例）：

1. **Stage 1**: 
   - 将守恒变量转换为原始变量: `eqn->consToPrim()`
   - 更新边界条件: `bnds->update()`
   - 调用 SpDistributor::rhsSolve() 计算右手端项
   - 更新守恒变量: `(*cons)[i]=tempdata[i]-dt*(*rhs)[i]`
   
2. **Stage 2**:
   - 重复上述过程，但使用加权平均更新守恒变量: `(*cons)[i]=0.75*tempdata[i]-0.25*dt*(*rhs)[i]+0.25*(*cons)[i]`
   
3. **Stage 3**:
   - 最后一次加权平均更新，完成一个时间步的计算: `(*cons)[i]=1.0/3.0*tempdata[i]-2.0/3.0*dt*(*rhs)[i]+2.0/3.0*(*cons)[i]`

## 4. 空间离散流程
SpDistributor::rhsSolve() 方法的执行流程：

1. 遍历每个计算维度（1D/2D/3D）
   - 一维计算: `if (dim >= 1)`
   - 二维计算: `if (dim >= 2)`
   - 三维计算: `if (dim >= 3)`
2. 对每个维度使用OpenMP并行化处理
   - `#pragma omp parallel for collapse(2) reduction(+ : timep) schedule(static)`
3. 为每个方向创建 SpaceDis 对象
   - 设置法向量: `spDis.setConstNorm({ 1, 0, 0 })`
   - 设置偏移量: `spDis.setOffset(offsets[0], offsets[1])`
   - 设置维度索引: `spDis.setIDim(0)`
4. 调用 SpaceDis::difference() 方法执行空间离散

## 5. 通量计算与重构流程
SpaceDis::difference() 方法的执行流程：

1. 调用 SpaceDis::calFlux() 计算界面通量
2. 根据选择的差分格式调用相应的方法（如 difTraditional6）

在 calFlux 过程中：
1. 对每个界面点调用相应的通量计算方法（如 calFluxEuler1D）
2. 在通量计算中会调用重构方法获取界面左右两侧的变量值

重构过程（以 ReconEigen1DEuler::recon() 为例）：
1. 获取特征投影矩阵: `eigensystemEuler1D eig=eigensystemEuler1D(primL,primR)`
2. 将物理变量投影到特征空间: `auto charTemp=eig.primToChar({at(j,R),at(j,U),at(j,P)})`
3. 在特征空间中执行WENO重构: `auto Q1LL=weno5_JSchen(q1L)`
4. 将重构结果投影回物理空间: `auto resTempL=eig.charToPrim({Q1LL,Q2LL,Q3LL})`

## 6. 数据流向
```
Info --> BlockSolver --> Initializer --> Block, Equation, Bnds, SpDistributor
                              |         |        |      |
                              v         v        v      v
                            网格数据   物理模型  边界条件  空间离散策略
                              |         |        |      |
                              v         v        v      v
                          SpaceDis <-- 数据流 --> rhs计算
                              |
                              v
                           时间推进(RK3-SSP等)
                              |
                              v
                          结果输出(CGNS格式)
```

整个计算流程形成了一个闭环：初始化 -> 时间推进循环 -> 输出结果，其中每个时间步内都包含完整的空间离散计算过程。